---
title: Ruby Tutorial
---

<div>
    <h1>Ruby Tutorial</h1>
    <div>
        <div id="intro" class="section">
            <h2>Introduction</h2>
            <h3>What is Ruby?</h3>
            <p>Ruby is "a dynamic, open sourced programming language with a focus on simplicity and productivity." Designed and developed in the mid-1990s by Yukihiro "Matz" Matsumoto in Japan, Ruby was influenced by Perl, Smaltalk, Eiffel, Ada, and Lisp. With a chief focus in flexibility, Ruby supports multiple programming paradigms, including functional, object-oriented, and imperative. Furthermore, Ruby is dynamically typed and employs an automatic memory management system. </p>
        </div>
        <div id="getting_started" class="section">
            <h2>Getting Started</h2>
            <h3>Installation</h3>
            <p>
                Before we start with the Ruby installation I'm going to assume that you are running Unbuntu or some other Linux distribution, either natively or in a virtual machine. If not, please make sure that you are                       before proceeding with the Ruby installation. Secondly, make sure that your distribution is up to date before proceeding.
            </p>
            <o1>
                <li>Install rbenv and ruby-build by running the following commands in the terminal:
                    <pre><code>$ git clone git://github.com/sstephenson/rbenv.git ~/.rbenv
$ echo 'export PATH="$HOME/.rbenv/bin:$PATH"' >> ~/.bashrc
$ echo 'eval "$(rbenv init -)"' >> ~/.bashrc

$ git clone git://github.com/sstephenson/ruby-build.git ~/.rbenv/plugins/ruby-build
$ echo 'export PATH="$HOME/.rbenv/plugins/ruby-build/bin:$PATH"' >> ~/.bashrc
$ exec $SHELL</code></pre>
                </li>
                <li>Next, install Ruby with the following commands in the terminal:
                    <pre><code># first install some Ruby dependencies
$ sudo apt-get install zlib1g-dev build-essential libssl-dev libreadline-dev
libyaml-dev libsqlite3-dev sqlite3 libxml2-dev libxslt1-dev

$ rbenv install 2.1.2
$ rbenv global 2.1.2  # set default ruby version
$ ruby -v # confirm it works</code></pre>
                </li>
            </o1>
        </div>
        <div id="arguments" class="section">
            <h2>Passing Arguments and Returning Values</h2>
            <h3>Returning Values</h3>
            <p>
                Unlike many other languages, Ruby methods <i>always</i> return a value. If no return value is specified, then a Ruby method will return the result of the last expression evaluated in the method.                                 For example, in the code below, the method would return <code>k</code> with a value of 0.
            </p>
            <pre><code>def test
    i = 100
    j = 10
    k = 0
end</code></pre>
            <p>
                Of course, if you want to return a different value, you can specify that with the <code>return</code> keyword as shown below. So here, in <code>method2</code>, instead of returning 3, or <code>a+b</code>, the method will return <code>b</code>'s value of 2 because it is explicitly stated.
            </p>
            <pre><code>def method2
    a = 1
    b = 2
    c = a + b
    return b   # returns 2
end</code></pre>
            <p>Let's look at some special cases below:</p>
            <pre><code>def method3
   "hello"     # returns "hello"
end

def method4
   a = 1 + 2
   "goodbye"   # returns "goodbye"
end

def method5
end            # returns nil

def ret_things
    greeting = "Hello world"
    a = 1
    b = 2.0
    return a, b, 3, "four", greeting, 6 * 10
end</code></pre>
            <p>As seen in <code>method3</code> and <code>method4</code>, assignments don't have to take place in order for a method to return a value. In <code>method5</code>, if the method body is empty, it will return <code>nil</code>. Finally, the method <code>ret_things</code> shows us that we can return multiple values! The return values are placed in an array in the same order that you've listed them.</p>
            <h3>Assignment and Parameter Passing</h3>
            <p>By now, I am sure that you are familiar with the terms <i>pass-by-value</i> and <i>pass-by-reference</i> with regard to parameter passing. In traditional terminology, Ruby is strictly pass-by-value; however, Ruby doesn't really have a pure, non-reference value. Instead, since variables are always references to objects, the object that is passed in is simply duplicated as another independent object. For example, in the code below, the object id of <code>num</code> will be different before and after the call to <code>change</code> is made.</p>
            <pre><code>def change( x )
    x += 1
    return x
end

...

num = 10
puts( "num.object_id=#{num.object_id}" )
num = change( num )
puts( "num.object_id=#{num.object_id}" )</code></pre>
            <p>Of course, there is always an exception to the rule and in this case, it's with intergers (or Fixnums). Every instance of a specific integer or every variable that is assigned that specific integer will have the same object id.</p>
            <h3>Modifying Receivers and Yielding New Objects</h3>
            <p>In Ruby, most methods do not change the value of the receiver ojbect and instead return a new object. In the example below, calling <code>reverse</code> doesn't change the value or object id of <code>str1</code>. Simply, a new object is returned and we can assign a variable to <code>str1.reverse</code> if we wish to retain the value returned.</p>
            <pre><code>str1 = "hello"
str1.reverse</code></pre>
            <p>If we want to directly modify the reciever, then we can use the <code>!</code> character as shown below. This time, calling <code>reverse!</code> on <code>str1</code> changes the value of <code>str1</code> to "olleh". However, note that a new object is not created and <code>str1</code> retains the same object id as before.</p>
            <pre><code>str1 = "hello"
str1.reverse!</code></pre>
            <h3>Parallel Assignment</h3>
            <p>Another handy feature of Ruby is the ability for parallel assignments. As we learned earlier, methods can return multiple values so it might help if we could assign those values to variables in a single line. The examples below illustrate this idea in practice.</p>
            <pre><code>s1, s2, s3 = "Hickory", "Dickory", "Dock"        #=> s1="Hickory", s2="Dickory", s3="Dock"

def returnArray( a, b, c )
    a = "Hello, " + a
    b = "Hi, " + b
    c = "Good day, " + c
    return a, b, c
end

x, y, z = returnArray( "Fred", "Bert", "Mary" )

# x = "Hello, Fred"
# y = "Hi, Bert"
# z = "Good day, Mary"</code></pre>
            <p>That's not it though! Parallel assignments also gives us the ability to swap the values of variables without creating a temporary variable.</p>
            <pre><code>i1 = 1
i2 = 2

i1, i2 = i2, i1        #=> i1 is now 2, i2 is 1</code></pre>
        </div>
        <div id="exceptions" class="section">
            <h2>Exception Handling</h2>
        </div>
    </div>
</div>
